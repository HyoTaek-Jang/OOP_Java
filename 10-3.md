체크드 익셉션은 컴파일러가 익셉션을 핸들링 하는지 체크하는 것
체크드 익셉션이 발생할 가능성이 있으면 캐치하거나 선언해야함. -> 캐치 디클레어 룰 catch or declare rule
트라이 캐치를 안하면 함수에 thorows를 해줘야함.
트라이는 하나하나 하는게 아니라 나올 가능성이 있으면 다 넣음.

캐치나 선언을 안하면 컴파일러가 에러남.

예외가 있음. 조상이 thorows를 안하면 서브에선 조상에 없는 익셉션을 넣을 수 없음. 그래서 조상에 없는 에러는 서브에서 무조건 캐치를 해야함.

프로그래머가 익셉션 발생시키는 것. throw
: 먼저 익셉션 타입을 찾아야함.
: 컨스트럭트 익셉션 오브젝트하고 throw함
: 스트링을 매개변수로 주어서 이유를 메세지를 넣을 수 있음.

기존의 익셉션을 익스테드해서 새로운 익셉션 클래스를 만들 수 도 있음.
:필요한 메소드 생성자정도만 있어도 충분
: 메소드로 설명을 받거나 그정도..?

캐치에서 일부는 처리하고 호출을 다시해서 부가적인 익셉션 핸들링을 할수 있음. -> RETHOROWING, chaining exceptions
익셉션을 만들고 . initCause 원래 원인 코들르 덯어서 던질 수도 있음. 나중에 .getCause로 어떤 익셉션인지 알 수 있음.
시스템이 레이어드 시스템일때 사용함.

finally clause
: 캐치 아래에 사용하며 익셉션이 발생해도 안발생하든 꼭 실행되는 부분
: 만약 파일을 열었으면 닫는 액션을 파이널리에서 하든가 그럼 ㅇㅇ
파이널에서도 익셉션이 발생할 수 있기에 이중화 하기도 함. 리쓰로 해도 파이널리하고 올라감.
무슨일이 있어도 실행됨

try with resoureces
useflul shortcut
파이널리 안쓰고 유용하게 사용할 수 있음.
트라이가 끝나면 자동적으로 close가 되는. 그렇기에 autocloseable 인터페이스를 구현 꼭 해야함.
try(Resource res = ...){

}
여기서 자동으로 클로즈를 해줌 개꿀! 파이널리에서 클로스 안해도 돼
리소스가 여러개면 세미콜론하고 또 하나 더 쓰고 하면 된다.

간단한 테스트를 굳이 익셉션 핸들링 하는 것은 좋은게 아님. 예를 들어 스택에서 임티인데 팝을 하는 경우? 단순히 테스트를 하면 됨.
라이브러리는 익셉션 핸들링을 하고 테스트는 라이브러리가 아닌 사용자가 다루는 코드에서 실행해야함.
런타임 익셉션을 뜨로우하지말고 체크드 익셉션을 다뤄라.
익셉션을 또 다른 익셉션으로 리뜨로할수있다. 캐치에서 아무것도 하지마라. 뭔가 처리를 해라
처리할 수 없으면 위로 올려라
