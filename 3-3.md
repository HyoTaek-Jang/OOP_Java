객체지향에서 클래스의 역할 : 객체를 생성하기 위한 코드 템플릿(인스턴스), 객체의 타입 - user-defined types

타입을 선언하는 이유 : 적적한 메모리를 할당하기 위해. 변수가 제대로 사용되는지 타입 체킹용, 메소드를 부를떄 메소드가 오브젝트에 실행되는지 체크 하는거

클래스의 종류
라이브러리 클래스, user defined classes 둘다 유저 디파인 타입이긴함.

workhorse class(domain class) without main methods(카드게임에서 카드나 플레이어), 공통으로 활용되는 클래스
a special(application) class with main method (카드게임에서 게임하는거)

클래스의 일반 구조
class ClassName{
instance_variable(field or instance field)

}

별도에 파일에 클래스를 쓰면 이름이랑 클래스 이름이 같고 퍼블릭으로 해야함.

instance variable
메소드가 쉐어하는 변수 메소드 바깥에서 있는 변수 클래스 스코프로 클래스 전체에서 사용가능. 변수의 값을 클래스로 부터 생성되는 객체 데이터에 값이 저장됨.
모든 클래스 인스탄스는 자신의 고유한 카피를 갖고있다.

초기화 방법

1. 선언에서 초기화 - 모든 객체가 같은 값을 가질때
2. 생성자 함수로 초기화 : 만약 안하면 디폴트 값을 가짐. null 0 false 이런식

인스턴스 변수의 스코프는 클래스 전부. 스테틱 메소드에선 예외임.(스테틱 메소드는 스테틱 변수만 쓸 수 있음)
오브젝트가 사라질때까지 존재함

생성자는 대부분 퍼플릭으로 만들어짐 외부에서 new로 만들어지기 때문
생성자는 리턴벨류 없음
오버로딩으로 많이 만들기도 함.

메소드 콜
객체에 따라서 하나의 코드가 실행될때 사용되는 데이터가 다름
하나의 호출이 다른 메소드를 호출할 수 있음. 같은 클래스 내에서.

this
psedu variable
this는 메소드 호출마다 들어있다고 생각하면 됨. 메소드가 호출된 레퍼런스를 가르킴
salary가 실제로는 this.salary임 근데 메소드가 호출된 레퍼런스가 각각 this가 되니까 다른 값이 전달 되는 거임.
임플릭트하게 전달되지만 익스플리시드하게 사용됨.
