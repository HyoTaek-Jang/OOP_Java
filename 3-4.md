parameter passing
call by value : 매개변수의 값을 카피해서 전달하는 것. 변경은 못시킴.

객체를 전달하면 객체의 주소가 전달됨. -> 객체를 전달하는 변수는 객체를 저장하는 게 아니라 객체의 레퍼런스를 저장하기때문
그래서 수정이 가능함.

자바는 무조건 call by value 레퍼런스도 오브젝트 자체가 아니라 벨류인 레퍼런스 값이 전달 되는 겨

매개변수는 바뀔 수 있는데 변수 자체값은 변경이 안됨

메소드 오버로딩
같은 클래스 내에 같은 이름의 메소드가 여러번 선언됨 하지만 파라메터의 셋이 달라야함.
오버로딩은 이름을 짓는데 노력을 줄여줌
호출시 컴파일러는 어케 구분하냐? -> 컴파일러가 매개변수의 타입,갯수,순서를 고려해서 일치되는 메소드를 호출하는 것
파라매터가 같고 리턴 타입이 다르면 오버로딩이 아님. 리턴타입은 고려사항이 아니야
-> 파라매터로 구분해서 컴퓨터는 구분할 수 없음

메소드 오버로딩은 스태틱도 되고 아니여도 됨 그리고 생산자도

캡슐화
퍼플릭, 프라이빗
퍼플릭은 클래스 외부에서도 access가능
프라이빗은 오직 클래스 내부에서만 가능

data abstraction.. -> 캡슐화하려고 찾아내는 과정

프라이빗 데이터는 메소드를 통해서 수정하고 얻어내고 함.

get set의 장점
내부 변화가 있을 때 외부에선 그대로 사용해도 ㄱㅊ
외부 변화에 영향을 받지 않음.

validated가 쉬움(올바른지 확인하는 것)

외부 변수로 객체 데이터를 조작하게 하면 안됨.리턴할때 레퍼런스를 넘겨주면 안됨.
mutable 객체는 리턴을 안하는게 낫다.

한 메소드는 같은 클래스의 동일한 타입의 다른 오브젝트의 프라이빗 데이터를 엑세스 할 수 있음. 물론 이게 좋은 방법은 아님.-> 자바는 객체 중심의 캡슐화가 아니라 클래스 단위의 캡슐화임.
