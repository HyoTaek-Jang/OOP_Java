Generic Array List
어레이는 동적할당이 안되서 다이나믹한 데이터를 구현하기에 불편함이 있음.
어레이 리스트는 필요에 따라 데이터 추가 삭제가 가능함. 즉, 어레이의 크기의 가변성
<T> 다양한 타입을 지원함.
diamond syntax new 에선 <>로 해도 됨.
var staff = new ArrayList<Employee>() inferencing type 이러면 추론해서 타입을 정해줌
(100) : 이니셜 카파시티(잠재적으로 사이즈가 100개정도 확보되있음.), 사이즈(실제 앨리먼트가 들어가 있는 수)랑 다름.
인덱스는 0부터
remove(i) i번째 삭제
remove(객체) 리스트 앞에있는 같은 객체를 삭제. equal로 확인해서 ㅇㅇ
for each 사용가능

object wrappers and autoboxing
<T> -> 클래스만 들어갈 수 있음. 원시타입 안됨.
원시타입을 오브젝트로 바꿔주는 랩퍼,
int - Integer 이런식

랩퍼 클래슨 이뮤터블, 값 변경이 안됨. int i는 바뀌지만 Integer은 못바꿈~ 그리고 다 파이널이라 서브 클래스 못만듬.

오토박싱
: 인트를 그냥 사용하면 알아서 컴파일러가 Integer 객체로 바꿔서 넣어줌 개꿀띠!
오토 언박싱은 인티저로 받은걸 인트로 바꿔서 변수에 넣어준대~~~!~!~!~!~ 유후!
Integer n = 1000 오토박싱
n++ 오토언박싱
== 할때 레퍼런스가 같아야 참임!! 그래서 equals 사용해라!

Enumeration classI(enum type)
한정된 데이터를 열거형으로 묶음
이넘타입은 클래스안에 스태틱 인스턴스로 만들어져있음.
레퍼런스 타입임. Size 클래스 안에 상수가있음. 스태틱 파이널임.
원소나열법으로 만들어져있음. new로 더 못만듬. 이넘은 Enum<T>의 서브클래스임.
valueOf 스태틱메소드 values()메소드는 매개 값으로 주어지는 문자열과 동일한 문자열을 가지는 열거 객체를 리턴합니다.
values는 사이즈의 객체를 배열로 만들어 넘겨줌. 스태틱메소드
ordianl() 몇번째 열거 객체인지 알려줌

객체가 스트링과 만나면 toString을 호출함.

class class
자바 런타임 시스템은 모든 객체의 타입정보를 유지하고 있음
모든객체는 class 객체를 갖고있음.
다 class의 객체임.
class cl = 객체.getClass();
cl.getName() -> Employee
cl.newInstance();로 객체를 만들 수 있음. 어떤 객체가 올 지 몰라서 Object로 받고 나중에 형변환을 하던지 함.

forName으로 클래스 가질 수도 있음.
원시도 됨. 래퍼런스도 됨.
Class cl = Random.class
아까 이넘처럼 클래스 오브젝트는 어떻게 만들지 객체는 하나임. 다 똑같음, ==로 비교 가능.
리플랙션 객체를 통해 클래스의 정보를 분석함

프로그램은 데이터를 다루는데, 툴은 소스코드를 다룸. 툴에서 내부를 볼때 Class 를 사용함.
