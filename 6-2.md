다형성(polymorphism)
멀티 타입과 관련된 내용
상속의 타입 관점에서 나옴.
서브클래스는 서브타입이다., 서브클래스의 모든 오브젝트는 수퍼클래스의 오브젝트이기도 함.

폴리몰피즘
다른 타입에서 싱글 인터페이스를 제공
ex)오버로딩.

subtype polymorphism(inclusion polymorphism)
어떤 변수는 서브클래스 변수를 가르킴.
수퍼클래스 메소드는 서브클래스에서 오버라이딩됨.
메소드 호출과 바인딩되는 시점이 다이나믹하다. 실제 메소드를 고르는 과정이.

서브타입 다형성의 장점
쉽게 확장할 수 있다. 프로그램에서 간단하고 컴팩트하다.

메소드 콜 과정

1. 컴파일 타임때
   : 모든 메소드를 다 찾고 매개변수와 매칭되는 것을 찾음. 없으면 컴파일 에러
   : 찾은 메소드가 프라이빗 스태틱 파이널인지 체크. 이러면 static binding으로 그걸로 실행함.
2. runtime
   : 다이나믹 바인딩. 앞에 수식어가 없으면, 오버라이딩돼있으면 자신의 타입에 맞춰서 실행함.

같은 함수의 내용이 바뀌면 : 오버라이딩
함수 매개변수에 따라 다른 함수를 호출 하면 : 오버로딩

객체에서 함수를 호출하면, 수퍼와 자신의 클래스에서 메소드를 찾음. 그리고 실행
다이나믹 바인딩으로 다른 수퍼에서 함수를 실행해서 내부에 오버로딩된 함수를 실행하면 자신의 객체클래스의 오버로딩 함수를 실행함.

컴파일타임땐 자신의 객체에 맞는 함수를 실행하고
런타임 땐 정의된 객체보다 그냥 레퍼런스에 따른 객체에 맞춰 실행하는듯.

자바는 virtual 방식

Empolyee a = new manager();

캐스팅 따로 안하고 그냥 임플로이가 됨.
Employee가 수퍼, 매니저에서 존재하는 함수를 호출해도 실행이 됨. 다이나믹 바인딩
근데 m = e는 안됨. 배열안에 m이 있어도 그냥 배열자체가 e면 컴파일에러
하고싶으면 e배열을 m으로 캐스팅해줘야함. -> 다운캐스팅. 수퍼에서 서브타입으로 낮추는것.
근데 만약 e에 객체가 m이 아니면 클래스캐스팅익셉션뜸. 오류뜬다고

instanceof 타입확인 명령어.

매개변수에 수퍼와 서브타입 다른 함수를 놓아도 오버라이딩 아니라 오버로딩임. 매개변수가 다른거로 함.
리턴타입이 서브,수퍼 다른것은 오버라이딩 됨. -> covariant

@override 라고 쓰면 오버라이딩이 제대로 되는지 확인하고 아니면 에러띄움.

오버로딩 리턴타입 상관없음, 스태틱바인딩

protected 서브클래스에서 쓸 수 있는 놈은 직접 액세스 가능.
A가 수퍼. B가 서브면 B에서 a.salay 가능. 근데 캡슐화가 깨져서 잘 안씀.
final class는 더이상 확장이 불가능함. 자바 api에 많이씀. string, math, system
오버라이딩 막으려고 쓰기도 함.
