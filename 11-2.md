제네릭은 타입 변수를 씀 <T> 빌트인 타입 뺴고 어떤 타입이든 매핑이 됨. 어떤 상황에선 모두 클래스에 대응이 안되는 상황도 있음.

컴페어투를 쓸 때 이것도 타입변수를 써서 어떤 클래스가 올지 알아야하는데 타입변수라서 어떤 타입이 올지 모른다 이거지. 만약 컴페어투를 구현하지 않은 클래스를 타입변수로 받으면 정상적으로 작동을 안해서!

타입변수를 특정 클래스 군으로 한정 짓는거 -> bound.
public static <T extends Comaparable<T>> T min(T[] a)-> T는 컴페러블의 서브타입이여야 한다.

String이랑 LocalDate는 컴퍼러블을 구현하고 있음. 그래서 위 함수를 호출 가능.

타입변수는 멀티플 바운드 가능 T extends Object & Comparable<T> 두개를 상속받아야한다.

제네릭 클래스를 자바에서 어떤 방식으로 구현하는가.
JVM에선 제네릭 타입이나 메소드 개념이 없음. 컴파일러가 중간 작업을 해줌. 이것이 Type Erasure
타입을 다 지우면 Raw type. <T>라는 타입을 지우고 bounding tpye으로 바꿈 없다면 Object로 바꿈.

오브젝트로 제네릭을 구현한 모습과 똑같음. 왜 제네릭으로 만들고 컴파일러는 저 모습으로 바꾸는가??
그냥 오브젝트로 만들면 컴파일러가 타입체킹도 못하고 오브젝트에 혼합된 데이터가 들어가고 꺼낼때 어떤 객체가 있는지 기억하고 변환시키면서 코딩을 해야하는 불편함이 있음. 그래서 컴파일러가 뭔가 체킹할 수 있게 타입 체킹하는 단계를 제공해줌. 실행할땐 신경을 안쓰고 바로 실행하는거지. 변수에 같은 타입임을 컴파일러가 보장을 해줌. 값을 꺼낼때도 컴파일러는 어떤 값임을 알기에 캐스팅도 컴파일러가 다 해줌.

제네릭 메소드를 호출할 때 리턴타입이 없어짐. 근데 컴파일러가 체크를 해놔서 리턴할때 기억한 타입으로 캐스팅을 해서 리턴을 함. 필드도 똑같음. 엑세스 할땐 타입 컨버젼을 해줌. 다 오브젝트 타입이니까 자동 캐스팅을 해서 사용하는거제

파라미터로 받아서 set하는건 erased안함. object이니까 그냥 받아서 넣으면 됨. 꺼낼때나 변수에 값을 넣으니까 캐스팅하는거지.

이 모든걸 컴파일러가 한다. 개똑똑해!!!!

calling Legacy code
레거시 코드랑 혼합하여 쓸 수 있게 하는게 주요 목표임. 제네릭의 목표!
제네릭타입은 implictly casted가 가능함.
근데 제네릭이랑 raw타입을 혼합하면 경고를 함.

제네릭 타입이랑 조상의 관계
매니저가 임플로이의 서브클래스면 Pair<매니저>는 Pair<임플로이>의 서브클래스? 결론은 아니다
두 관계는 아무 관게가 없음. 제네릭은 그냥 별개임.
근데 배열에서 임플로이 배열과 매니저 배열은 서브타입임. -> covariant

배열에서 런타입 익셉션. 제네릭에서는 타입이레이저 떄문에 이런 일이 안일어남...? 헷갈리네
그래서 제네릭에선 상속을 허용하지 않음...?
Pair<manager>는 Pair의 서브타입. Pair가 로우타입
로우타입에 Object니까 뭘 넣든 넣어짐. 꺼낼때 문제지. classcastException뜸
