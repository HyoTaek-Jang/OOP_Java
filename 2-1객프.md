자바의 모든것은 클래스 안에 들어가있음

퍼블릭은 외부에서 호출 가능한 접두어

프로그램을 실행하면 jvm이 메인 함수를 호출함.

식별자를 만들땐 클래스를 대문자로 시작, 함수나 변수는 소문자로 시작, 두 단어 이상일떈 카멜케이스 CamelCase

자바의 소스 파일은 클래스 이름과 동일하게 만듬

C의 표준 출력 printf
자바는 함수를 바로 부르지 않고 표준 출력을 담당하는 객체를 부름 -> system.out
객체는 사각형으로 표현
newline은 c와 동일한 \n

주석처리는 씨와 동일.
Documentation comments: javadoc에서 html로 추출 가능

자바는 strongly typed -> 타입을 엄격하게 체크함
모든 변수가 미리 선언되고 타입들이 컴파일 타입이나 런타임때 꼭 체크되야하함

primitive types : 값이 직접있음
reference types : 메모리에 값을 넣지않고 값이 있는 위치의 정보를 넣음

씨랑 다르게 string을 지원함. primitive X 클래스임

numeric data types
int short long byte
자바는 머신을 타지 않아서 어떤 플랫폼에서 실행되는 상관없음

float double
기본적으로 실수는 double 만약 플로트로 하고싶으면 숫자 뒤에 f를 붙여줘야함

특수값이 있음
양의 무한, 음의 무한, NaN, 0/0은 오류로 날아감

Char type
자바의 모든 문자를 표현하진 못함

아스키코드는 8비트로 표현됨 -> 너무 작아서 표현 못하는 게 많음 -> 16비트 유니코드 탄생(자바도 이거로 char을 만듬) -> 한계를 느낌 -> 추가코드를 만듬 이걸 supplementary char -> 이러한 문자의 각각 유니크한 벨류를 코드 포인트라함 단순하게 유니코드 캐릭터의 일련번호

코드포인트는 코딩체계가 아님 실제 메모리에 저장되는 값은 따로있음
자바는 utf-16, utf-32는 코드포인트를 그대로 가져와서 쉽지만 메모리 낭비가 심함 -> 텍스트의 문자는 대부분 16에 들어가있음
utf-8에선 각각 코드 포인트가 1-4바이트(웹에서 주로 사용)

코트포인트 BMP: 하나의 코드 유닛
나머지 supple : 32비트 두개의 코드 유닛

boolean
자바는 불리언을 따로 둬서 인트와 다르게...?
자바가 더 견고하다 robust하다

스코프를 통해 변수의 생명을 정함
자바는 글로벌변수가 없고 로컬이 아니면 클래스 스코프를 갖는 변수
블록이 중첩되어있으면 가장 안쪽에서 가까운 변수를 가져옴

상수 const(씨에서) final(자바 로컬변수) static final(자바 클래스에서)

Type conversions
작은거랑 큰거를 혼합하면 큰거로 바뀜 (정보의 손실을 없애기 위해)
점선으로 표현된거는 정보의 손실이 있을 수 있음. 왜냐하면 유효자리의 차이때문에
cast로 강제로 형변환 가능 (int) 이렇게
